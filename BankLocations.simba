type

  TWaspBanking = record
    Action: String;
  end;

var
  WaspBanking: TWaspBanking;
  BankRSW: TRSWalker;

  VWestBank0 := Point(4553, 2673);
  VWestBank1 := Point(4553, 2680);
  VWestBank2 := Point(4553, 2688);
  VWestBank3 := Point(4553, 2696);
  VWestBank4 := Point(4554, 2705);

  VWestBank := [VWestBank0, VWestBank1, VWestBank2, VWestBank3, VWestBank4];
  VWBankColor := CTS2(998986, 12, 0.13, 2.87);

  GEWestBank0 := Point(4459, 2487);
  GEWestBank1 := Point(4459, 2491);
  GEWestBank := [GEWestBank0, GeWestBank1];

  GEEastBank0 := Point(4476, 2488);
  GEEastBank1 := Point(4476, 2492);
  GEEastBank := [GEEastBank0, GEEastBank1];

  GEBanks := [GEWestBank0, GeWestBank1, GEEastBank0, GEEastBank1];
  GEStructureColor := CTS2(2971242, 23, 0.05, 1.10);

  EdgeWestBank0 := Point(4189, 2492);
  EdgeWestBank1 := Point(4189, 2483);
  EdgeWestBank := [EdgeWestBank0, EdgeWestBank1];

  EdgeNorthBank0 := Point(4201, 2476);
  EdgeNorthBank1 := Point(4193, 2476);
  EdgeNorthBank := [EdgeNorthBank0, EdgeNorthBank1];
  EdgeBank := [EdgeWestBank0, EdgeWestBank1, EdgeNorthBank0, EdgeNorthBank0];

  EdgeBankColor := CTS2(2711941, 22, 0.12, 2.21);

  CWBank := Point(1586, 4115);
  CWBankColor := CTS2(4475747, 15, 0.27, 1.09);

  FWestBank0 := Point(3589, 2980);
  FWestBank1 := Point(3593, 2980);
  FWestBank2 := Point(3597, 2980);
  FWestBank3 := Point(3601, 2980);
  FWestBank4 := Point(3605, 2980);
  FWestBank := [FWestBank0, FWestBank1, FWestBank2, FWestBank3, FWestBank4];
  FWestBankColor := CTS2(3230556, 21, 0.09, 0.91);

  CraftGuildBank := Point(3554, 3328);
  CraftGuildBankColor := CTS2(3230556, 21, 0.09, 0.91); //just copied from cwbank as a placeholder... need to add proper color later

  ClosestBankTile: TPoint;
  ClosestBankTiles: TPointArray;
  ClosestBankColor: TCTS2Color;

// Tries to open a bank with the specified Color at the specified Tile.
// Returns true if bankscreen is open.
function WaspBanking.OpenBank(Tile: TPoint; Color: TCTS2Color): Boolean;
begin
  Result := Obj.Click(Tile, Color, ['Bank', 'booth', 'chest'], True, 2, BankRSW);
end;

// Same as above for multiple tiles.
function WaspBanking.OpenBank(Tiles: TPointArray; Color: TCTS2Color): Boolean; overload;
begin
  Result := Obj.Click(Tiles, Color, ['Bank', 'booth', 'chest'], True, 2, BankRSW);
end;

// Loads a smaller map in a new instance of RSW for faster execution.
// Optionally you can set it to free the whole world map that is
// automatically loaded with my lib on WaspRSW.
procedure WaspBanking.LoadMap(DisableWorldWalker: Boolean = True);
begin
  if Wasp.AtLocation(VWestBank, 100) then
  begin
    BankRSW.InitEx('world', [[3, 5], [3, 6]]);
    ClosestBankTiles := VWestBank;
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := VWBankColor;
  end

  else if Wasp.AtLocation(FWestBank, 100) then
  begin
    BankRSW.InitEx('world', [[3, 4]]);
    ClosestBankTiles := FWestBank;
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := FWestBankColor;
  end
  
  else if Wasp.AtLocation(CraftGuildBank, 100) then
  begin
    BankRSW.InitEx('world', [[4, 4]]);
    ClosestBankTiles := [CraftGuildBank];
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := CraftGuildBankColor;
  end

  else if Wasp.AtLocation(EdgeBank, 100) then
  begin
    BankRSW.InitEx('world', [[3, 5]]);
    ClosestBankTiles := Self.GetClosestTile(EdgeNorthBank, EdgeWestBank);
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := GEStructureColor;
  end

  else if Wasp.AtLocation(GEBanks, 100) then
  begin
    BankRSW.InitEx('world', [[3, 5], [3, 6]]);
    ClosestBankTiles := Self.GetClosestTile(GEWestBank, GEEastBank);
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := GEStructureColor;
  end

  else if Wasp.AtLocation(CWBank, 100) then
  begin
    BankRSW.InitEx('world', [[5, 1], [5, 2]]);
    ClosestBankTiles := [CWBank];
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := CWBankColor;
  end;

  if DisableWorldWalker then
    WaspRSW.Free();
end;

// Same as above but uses only the already existing instance (WaspRSW) that my lib starts
// I usually prefer the method above and most of the functions on this file assume BankRSW is properly setup.
procedure Wasp.LoadSmallerMap();
begin
  if Self.AtLocation(VWestBank, 100) then
  begin
    Self.LoadMapSlices('world', [[3, 5], [3, 6]]);
    ClosestBankTiles := VWestBank;
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := VWBankColor;
  end

  else if Self.AtLocation(EdgeWestBank, 100) then
  begin
    Self.LoadMapSlices('world', [[3, 5]]);
    ClosestBankTiles := EdgeWestBank;
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := EdgeBankColor;
  end

  else if Self.AtLocation(GEBanks, 100) then
  begin
    Self.LoadMapSlices('world', [[3, 5], [3, 6]]);
    ClosestBankTiles := WaspBanking.GetClosestTile(GEWestBank, GEEastBank);
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := GEStructureColor;
  end

  else if Self.AtLocation(CWBank, 100) then
  begin
    Self.LoadMapSlices('world', [[5, 1], [5, 2]]);
    ClosestBankTiles := [CWBank];
    ClosestBankTile := ClosestBankTiles[Random(0, High(ClosestBankTiles))];
    ClosestBankColor := CWBankColor;
  end;
end;

// Checks if we are at specified Distance from a Tile.
function WaspBanking.AtLocation(Tile: TPoint; Distance: Int32 = 30): Boolean;
begin
  Result := (BankRSW.GetMyPos.DistanceTo(Tile) <= Distance);
end;

// Same as above but with arrays. Checks if any of the Tiles in the array is within
// the specified Distance and if yes returns True.
function WaspBanking.AtLocation(Tiles: TPointArray; Distance: Int32 = 30): Boolean; overload;
var
  i: Int32;
begin
  Result := False

  for i := 0 to High(Tiles) do
  begin
    if (BankRSW.GetMyPos.DistanceTo(Tiles[i]) <= Distance) then
      Exit(True);
  end;
end;

// Compares 2 Tiles with the Player position and returns the closest one.
// If the Distance is the same for both, will return a random one.
function WaspBanking.GetClosestTile(Tile1, Tile2: TPoint): TPoint;
begin
  if BankRSW.GetMyPos.DistanceTo(Tile1) = BankRSW.GetMyPos.DistanceTo(Tile2) then
  begin
     case Random(0,1) of
      0: Result := Tile1;
      1: Result := Tile2;
     end;
  end
  else if BankRSW.GetMyPos.DistanceTo(Tile1) < BankRSW.GetMyPos.DistanceTo(Tile2) then
    Result := Tile1
  else if BankRSW.GetMyPos.DistanceTo(Tile1) < BankRSW.GetMyPos.DistanceTo(Tile2) then
    Result := Tile2;
end;

// Same as above but with arrays. Finds the closes distance to the closest tile of each array
// and returns the closest array. If the Distance is the same for both, will return a random one.
function WaspBanking.GetClosestTile(TileArray1, TileArray2: TPointArray): TPointArray; overload;
var
  i: Int32;
  Distances1, Distances2: TExtendedArray;
begin

  for i := 0 to High(TileArray1) do
    Distances1 += BankRSW.GetMyPos.DistanceTo(TileArray1[i]);

  for i := 0 to High(TileArray2) do
    Distances2 += BankRSW.GetMyPos.DistanceTo(TileArray2[i]);

  if Distances1.Min() = Distances2.Min() then
  begin
     case Random(0,1) of
      0: Result := TileArray1;
      1: Result := TileArray2;
     end;
  end
  else if Distances1.Min() < Distances2.Min() then
    Result := TileArray1
  else if Distances1.Min() > Distances2.Min() then
    Result := TileArray2;
end;

// Opens the closest bank supported by WaspBanking.
// Use this in your script to open a bank with a single line of code.
function WaspBanking.OpenClosestBank(): Boolean;
begin
  if not Self.AtLocation(ClosestBankTile) then
    Exit(False);

  Result := Self.OpenBank(ClosestBankTile, ClosestBankColor);
end;


procedure WaspBanking.Free();
begin
  BankRSW.Free();                             ;
end;

begin
  AddOnTerminate(@WaspBanking.Free);
end;
