// Lot's of this functions are based on Slacky's functions
type
  TMSObject = record
    WorldLoc: TPointArray;  //loctions on the world map
    Color: TCTS2Color;      //must have color
    MinCount: Int32;        //size of TPA
    SplitDist: Int32;
  end;

var
  Obj: TMSObject;


// Searches for a color in the MainScreen with the help of RSWalker.
function TMSObject.Find(DoSort: Boolean = True; Expand: Int32 = 0; Map: TRSWalker = WaspRSW): TRectArray;
var
  Loc, Me: TPoint;
  rect: TRectangle;
  locations, TPA: TPointArray;
  ATPA: T2DPointArray;
begin
  Me := Map.GetMyPos();
  locations := Copy(Self.WorldLoc);
  if DoSort then Locations.Sorted(Me);

  for Loc in Locations do
  begin
    rect := Map.GetTileMSEx(Me, Loc, 1).Expand(Expand);
    if MainScreen.GetBounds.Contains(rect.Bounds) then
    begin
      if (srl.FindColors(TPA, Color, rect.Bounds) < Self.MinCount) then
        Continue;

      if (Self.SplitDist > 0) then
      begin
        TPA  := rect.Filter(TPA);
        ATPA := TPA.Cluster(Self.SplitDist);
        ATPA.SortByMiddle(rect.Mean);
        if ATPA then
          Result += ATPA[0].MinAreaRect;
      end else
        Result += rect.Expand(-Expand);
    end;
  end;
end;

// Same as above but without RSWalker... useful for some stuff and should be faster too.
function TMSObject.FindMS(DoSort: Boolean = True): TRectArray; overload;
var
  Me: TPoint;
  TPA: TPointArray;
  Rect: TRectangle;
  SearchBox: TBox;
  ATPA: T2DPointArray;
begin
  Me := MainScreen.GetMiddle();

  SearchBox := MainScreen.GetBounds();
  Rect := SearchBox.ToRectangle();

  srl.FindColors(TPA, Color, SearchBox);
  MainScreen.FilterPlayerBox(TPA);

  if DoSort then TPA.Sorted(Me);

  TPA  := Rect.Filter(TPA);
  ATPA := TPA.Cluster(8);
  ATPA.SortByMiddle(Rect.Mean);
  if ATPA then
    Result += ATPA[0].MinAreaRect;
end;

// Searches for a color in a certain tile and clicks it if found.
function TMSObject.Click(Tile: TPoint; Color: TCTS2Color; SubStrs: TStringArray; HasInterface: Boolean = False; Attempts: Int32 = 2; Map: TRSWalker = WaspRSW; DoSort: Boolean = True): Boolean;
var
  Rectangles: array of TRectangle;
  Rectangle: TRectangle;
  i: Int32;
  t: UInt64;
begin

  Result := False;
  if not Wasp.IsTileVisible(Map, Tile) then
    Exit(False);
  for i := 1 to Attempts do
  begin
    Obj := [[Tile], Color, 200, 8];

    t := GetTickCount() + 3000;
    repeat
      Rectangles := obj.Find(DoSort, 20, Map);
      if (GetTickCount() >= t) then
        Exit(False);
    until Rectangles;
    Rectangle := Rectangles[Random(0, High(Rectangles))];

    mouse.Move(SRL.RandomPoint(Rectangle));

    if MainScreen.IsUpText(SubStrs) then
    begin
      if mouse.Click(ctRed) then
      begin
        if not HasInterface then
          Exit(True);

        Minimap.WaitPlayerMoving(False, 3000);
        t := GetTickCount() + 4000;
        repeat
          if Wasp.IsInterfaceOpen() then
            Exit(True)
          else
            Wait(Random(25, 50));
        until (GetTickCount() >= t);
      end;
    end;

    Minimap.RandomCompass(-180,180);
  end;
end;

// Searches for a color in several tiles and clicks it if found.
function TMSObject.Click(Tiles: TPointArray; Color: TCTS2Color; SubStrs: TStringArray; HasInterface: Boolean = False; Attempts: Int32 = 2; Map: TRSWalker = WaspRSW; DoSort: Boolean=True): Boolean; overload;
var
  Rectangles: array of TRectangle;
  Rectangle: TRectangle;
  i: Int32;
  t: UInt64;
begin

  Result := False;

  if not Wasp.AnyTileVisible(Map, Tiles) then
    Exit(False);
  for i := 1 to Attempts do
  begin
    Obj := [Tiles, Color, 200, 8];

    t := GetTickCount() + 3000;
    repeat
      Rectangles := obj.Find(DoSort, 20, Map);
      if (GetTickCount() >= t) then
        Exit(False);
    until Rectangles;

    Rectangle := Rectangles[Random(0, High(Rectangles))];

    mouse.Move(SRL.RandomPoint(Rectangle));

    if MainScreen.IsUpText(SubStrs) then
    begin
      if mouse.Click(ctRed) then
      begin
        if not HasInterface then
          Exit(True);

        Minimap.WaitPlayerMoving(False, 3000);
        t := GetTickCount() + 4000;
        repeat
          if Wasp.IsInterfaceOpen() then
            Exit(True)
          else
            Wait(Random(25, 50));
        until (GetTickCount() >= t);
      end;
    end;

    Minimap.RandomCompass(-180,180);
  end;
end;

procedure TMSObject.Debug(Map: TRSWalker = WaspRSW; Tile: TPoint; Color: TCTS2Color; DoSort: Boolean = True);
var
  BMP, i: Integer;
  TileBox, RectangleBox: TBox;
  Rectangles: array of TRectangle;
  RectanglesTPA: TPointArray;
  t: UInt64;
begin

  if not Wasp.IsTileVisible(Map, Tile) then
    Exit();

  Obj := [[Tile], Color, 200, 8];

  t := GetTickCount() + 3000;
  repeat
    Rectangles := obj.Find(DoSort, 15, Map);
    if (GetTickCount() >= t) then
      Exit();
  until Rectangles;

  for i := 0 to High(Rectangles) do
  begin
    RectangleBox := Rectangles[i].Bounds();
    RectanglesTPA += EdgeFromBox(RectangleBox);
  end;

  BMP := BitmapFromClient(GetClientBounds());
  TileBox := Map.GetTileMS(Tile).Bounds();

  DrawTPABitmap(BMP, EdgeFromBox(TileBox), 255);

  DrawTPABitmap(BMP, RectanglesTPA, 0);

  ShowBitmap(BMP);
  FreeBitmap(BMP);
end;

// NEED TO FIX THIS
procedure TMSObject.Debug(Map: TRSWalker; Tiles: TPointArray; Color: TCTS2Color; DoSort: Boolean = True); overload;
var
  BMP, i: Integer;
  TileBox, RectangleBox: TBox;
  Rectangles: array of TRectangle;
  RectanglesTPA: TPointArray;
  t: UInt64;
begin
  if not Wasp.AnyTileVisible(Map, Tiles) then
    Exit();

  BMP := BitmapFromClient(GetClientBounds());

  for i:=0 to High(Tiles) do
  begin

    Obj := [[Tiles[i]], Color, 200, 8];
    t := GetTickCount() + 3000;
    repeat
      Rectangles := obj.Find(DoSort, 15, Map);
      if (GetTickCount() >= t) then
        Exit();
    until Rectangles;

    TileBox := Map.GetTileMS(Tiles[i]).Bounds();

    for i := 0 to High(Rectangles) do
    begin
      RectangleBox := Rectangles[i].Bounds();
      RectanglesTPA += EdgeFromBox(RectangleBox);
    end;


    DrawTPABitmap(BMP, EdgeFromBox(TileBox), 255);
    DrawTPABitmap(BMP, RectanglesTPA, 0);


  end;

  ShowBitmap(BMP);
  FreeBitmap(BMP);
end;
